# JVM总结

## 一、JVM组成

* 内存结构
* 垃圾回收
* 类加载与字节码技术
* 内存模型



## 二、内存结构

* 程序计数器
* 虚拟机栈
* 本地方法栈
* 堆
* 方法区
* 直接内存



## 三、垃圾回收

### 1、如何判断垃圾可回收

引用计数法、可达性分析算法（GC Root）、四种引用（强、软、弱、虚、终结器）

### 2、垃圾回收算法

标记清除、标记整理、复制

### 3、分代垃圾回收

① 对象首先分配在伊甸园区域 

② 新生代空间不足时，触发 minor gc，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的对象年龄加 1并且交换 from to 

③ minor gc 会引发 stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行 

④ 当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（4bit） 

⑤ 当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍不足，那么触发 full gc，STW的时间更长 



## 四、垃圾回收器

* 串行
* 吞吐量优先
* 响应时间优先
* G1： 整体上是 标记+整理 算法，两个区域之间是 复制 算法 
* 垃圾回收调优



## 五、类加载与字节码技术

### 1、类文件结构

魔数、版本、常量池、访问标志与继承信息、Field信息、Method信息、附加属性

### 2、字节码指令

① 入门、javap工具、图解方法执行流程（原始 Java代码、编译后的字节码文件、常量池载入运行时常量池、方法字节码载入方法区、main线程开始运行 分配栈帧内存、执行引擎开始执行字节码）、构造方法

② 方法调用： new 是创建【对象】，给对象分配堆内存，执行成功会将【对象引用】压入操作数。 dup 是赋值操作数栈栈顶的内容，本例即为【对象引用】，为什么需要两份引用呢，一个是要配合 invokespecial 调用该对象的构造方法"<init>":()V（会消耗掉栈顶一个引用），另一个要配合 astore_1 赋值给局部变量 

③ 多态的原理：运行代码、运行HSDB工具、查找某个对象、查看对象的内存结构、对象Class的内存地址、类的vtable、验证方法地址

④ 异常处理：try-catch、single-catch、multi-catch、finally

### 3、编译器处理

默认构造器、自动拆装箱、泛型集合取值、可变参数、foreach循环、switch字符串、switch枚举、匿名内部类

### 4、类加载阶段：

① 加载：加载和链接可能交替运行

② 链接：验证（是否为Class文件）--准备（为static变量分配空间默认值）--解析（ 将常量池中的符号引用解析为直接引用 ）

③ 初始化：< cinit（） >

### 5、类加载器

启动类加载器、扩展类加载器、双亲委派模式（ 有上级的话，委派上级loadClass ）、线程上下文类加载器、自定义加载器

### 6、运行期优化

即时编译（分层编译、方法内联、字段优化）反射优化

 即时编译器（JIT）与解释器的区别 

>  解释器是将字节码解释为机器码，下次即使遇到相同的字节码，仍会执行重复的解释
>
> JIT 是将一些字节码编译为机器码，并存入 Code Cache，下次遇到相同的代码，直接执行，无需再编译
>
> 解释器是将字节码解释为针对所有平台都通用的机器码
>
> JIT 会根据平台类型，生成平台特定的机器码 



## 六、内存模型

### 1、Java内存模型

 java 内存模型 是 Java MemoryModel（JMM）的意思 

### 2、原子性

 两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果是 0 吗？ 

不是， 用synchronized解决并发问题。

### 3、可见性

 volatile（易变关键字） ： 它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存 

### 4、有序性

 volatile 修饰的变量，可以禁用指令重排 

### 5、CAS与原子类

CAS 即CompareandSwap，它体现的一种乐观锁的思想。 

获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。结合 CAS 和 volatile 可以实现无锁并发，适用于竞争不激烈、多核 CPU 的场景下。

 **乐观锁与悲观锁：**  

CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。

synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会 

### 6、synchronized 优化 

*  轻量级锁 

*  锁膨胀：如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级 

*  重量锁： 重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞

*  偏向锁 ： 是自己的就表示没有竞争，不用重新 CAS 

* 其他优化： 

  ① 减少上锁时间 

  ② 减少锁的粒度（ 将一个锁拆分为多个锁提高并发度 ）

  ③ 锁粗化 （多次循环进入同步块不如同步块内多次循环 ）

  ④ 锁消除 （ JVM 会进行代码的逃逸分析，例如某个加锁对象是方法内局部变量，不会被其它线程所访问到，这时候就会被即时编译器忽略掉所有同步操作 ）

  ⑤ 读写分离 



## PS：

JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。

JDK1.8开始，取消了Java方法区，取而代之的是位于直接内存的元空间（metaSpace）。

jdk 1.7后，移除了方法区间，运行时常量池和字符串常量池都在堆中。 